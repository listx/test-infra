/*
Copyright 2022 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package google

import (
	"context"
	"errors"
	"fmt"
	"io/ioutil"

	"golang.org/x/oauth2"
	googleOAuth "golang.org/x/oauth2/google"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/metadata"

	pb "k8s.io/test-infra/prow/gangway"
)

// This is the client library for Go clients that need to access to the Prow
// API, aka Gangway. This library assumes that Gangway is running in Google
// Cloud Platform, specfically using Cloud Endpoints.
//
// Go clients need to always append 2 things ot the metadata of a gRPC call:
//
//  	1. The JWT (authentication) token (to make the call identify itself as
//  	an allowlisted client in our api_config_auth.yaml configuration for Cloud
//  	Endpoints), and
//
//  	2. The API key (that is generated by the client's GCP Project).
//
//  The JWT token is generated from a GCP Service Account key file (JSON). The
//  API key is generated from the GCP user interface, like this:
//  https://cloud.google.com/docs/authentication/api-keys#create.
//
//  For us, the clients must supply the service account JSON key file, API key,
//  audience, and finally the address where Gangway is being served.
//
//		prowClient, err := client.NewFromFile(...) // Assume this package is imported as "client"
//		if err != nil { ... }
//
//		ctx, err := prowClient.MkContext()
//		if err != nil { ... }
//		prowClient.GRPC.CreateJobExecution(...)

type Client struct {
	// JWT token-based authentication and GCP Project identification (apiKey).
	keyBytes    []byte
	audience    string
	tokenSource oauth2.TokenSource

	// apiKey identifies the GCP Project.
	apiKey string

	addr string
	conn *grpc.ClientConn

	// GRPC is the auto-generated gRPC client interface for gangway.
	GRPC pb.ProwClient
}

// NewFromFile creates a Gangway client from a JSON service account key file and an audience string.
func NewFromFile(keyFile, audience, apiKey, addr, clientPem string) (*Client, error) {
	keyBytes, err := ioutil.ReadFile(keyFile)
	if err != nil {
		return nil, fmt.Errorf("Unable to read service account key file %s: %v", keyFile, err)
	}

	return New(keyBytes, audience, apiKey, addr, clientPem)
}

// New creates a new gRPC client. It does most of the legwork in NewFromFile().
func New(keyBytes []byte, audience, apiKey, addr, clientPem string) (*Client, error) {
	client := Client{}

	creds, err := credentials.NewClientTLSFromFile(clientPem, "")
	if err != nil {
		return nil, fmt.Errorf("could not process clientPem credentials: %v", err)
	}

	conn, err := grpc.Dial(addr, grpc.WithTransportCredentials(creds))
	if err != nil {
		return nil, fmt.Errorf("could not connect to %q: %v", addr, err)
	}
	client.conn = conn
	client.GRPC = pb.NewProwClient(client.conn)

	if len(audience) == 0 {
		return nil, errors.New("audience cannot be empty")
	}

	client.audience = audience

	if len(apiKey) == 0 {
		return nil, errors.New("apiKey cannot be empty")
	}

	client.apiKey = apiKey

	if len(keyBytes) == 0 {
		return nil, errors.New("keyBytes cannot be empty")
	}

	client.keyBytes = keyBytes

	tokenSource, err := googleOAuth.JWTAccessTokenSourceFromJSON(client.keyBytes, client.audience)
	if err != nil {
		return nil, fmt.Errorf("could not create tokenSource: %v", err)
	}

	client.tokenSource = tokenSource

	return &client, nil
}

// MkToken generates a new JWT token with a 1h TTL. This is apparently a
// cheap operation, according to
// https://github.com/GoogleCloudPlatform/golang-samples/blob/e7a5459d85661a35c5eb4f0b5759b7b30ac6ff90/endpoints/getting-started-grpc/client/main.go#L81-L88.
func (client *Client) MkToken() (string, error) {
	jwt, err := client.tokenSource.Token()
	if err != nil {
		return "", fmt.Errorf("could not generate JSON Web Token: %v", err)
	}

	return jwt.AccessToken, nil
}

// MkContext() is used to create a context that has the the necessary token and
// apiKey attached to it.
func (client *Client) MkContext() (context.Context, error) {
	ctx := context.Background()

	ctx = metadata.AppendToOutgoingContext(ctx, "x-api-key", client.apiKey)

	token, err := client.MkToken()
	if err != nil {
		return ctx, err
	}

	fmt.Printf("using token %q\n", token)

	ctx = metadata.AppendToOutgoingContext(ctx, "Authorization", fmt.Sprintf("Bearer %s", token))

	return ctx, nil
}

func (client *Client) Close() {
	client.conn.Close()
}
